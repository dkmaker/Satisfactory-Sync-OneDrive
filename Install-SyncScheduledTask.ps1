#Requires -Version 5.1
#Requires -RunAsAdministrator
<#
.SYNOPSIS
    Installs a scheduled task to run Satisfactory blueprint sync every 10 minutes
.DESCRIPTION
    Creates a Windows scheduled task that runs the sync script every 10 minutes,
    whether the user is logged in or not, using Windows PowerShell with hidden window
#>

[CmdletBinding()]
param(
    [Parameter()]
    [string]$SourceScriptPath = (Join-Path $PSScriptRoot "Sync-SatisfactoryBlueprints.ps1"),

    [Parameter()]
    [string]$InstallPath = "$env:OneDrive\Documents\Satisfactory\Sync",

    [Parameter()]
    [string]$TaskName = "SatisfactoryBlueprintSync",

    [Parameter()]
    [int]$IntervalMinutes = 10,

    [Parameter()]
    [switch]$Force
)

# Verify running as administrator
$currentPrincipal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())
if (!$currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
    Write-Error "This script must be run as Administrator. Please run PowerShell as Administrator and try again."
    exit 1
}

# Verify Windows PowerShell is available
$powershellPath = "$env:SystemRoot\System32\WindowsPowerShell\v1.0\powershell.exe"
if (!(Test-Path $powershellPath)) {
    Write-Error "Windows PowerShell is not found at expected location: $powershellPath"
    Write-Host "Windows PowerShell should be available by default on Windows 10/11" -ForegroundColor Yellow
    exit 1
}

# Verify source sync script and VBScript wrapper exist
if (!(Test-Path $SourceScriptPath)) {
    Write-Error "Source sync script not found at: $SourceScriptPath"
    exit 1
}

# VBScript wrapper is generated dynamically, no template file needed

# Create installation directory if it doesn't exist
Write-Host "Setting up installation directory..." -ForegroundColor Yellow
if (!(Test-Path $InstallPath)) {
    New-Item -Path $InstallPath -ItemType Directory -Force | Out-Null
    Write-Host "Created installation directory: $InstallPath" -ForegroundColor Green
}

# Copy script and generate VBScript wrapper
$ScriptFileName = "Sync-SatisfactoryBlueprints.ps1"
$ScriptPath = Join-Path $InstallPath $ScriptFileName
$VBSFileName = "Sync-SatisfactoryBlueprints.vbs"
$VBSPath = Join-Path $InstallPath $VBSFileName

Write-Host "Copying sync script and creating customized VBScript wrapper..." -ForegroundColor Yellow
Copy-Item -Path $SourceScriptPath -Destination $ScriptPath -Force
Write-Host "PowerShell script copied to: $ScriptPath" -ForegroundColor Green

# Create customized VBScript wrapper with full paths
Write-Host "Generating VBScript wrapper with full installation paths..." -ForegroundColor Yellow

# Determine if we can use %OneDrive% environment variable
$useOneDriveEnv = $false
$oneDriveEnvPath = ""
if ($env:OneDrive -and $ScriptPath.StartsWith($env:OneDrive, [System.StringComparison]::OrdinalIgnoreCase)) {
    $relativePath = $ScriptPath.Substring($env:OneDrive.Length).TrimStart('\')
    $oneDriveEnvPath = "%OneDrive%\$relativePath"
    $useOneDriveEnv = $true
    Write-Host "Using OneDrive environment variable: $oneDriveEnvPath" -ForegroundColor Green
} else {
    Write-Host "Using full absolute path: $ScriptPath" -ForegroundColor Yellow
}

# Generate the VBScript content
$vbsContent = @"
' Satisfactory Blueprint Sync - VBScript Wrapper
' This script launches the PowerShell sync script with no visible window
' Used by Windows Task Scheduler for silent background execution
' Generated by Install-SyncScheduledTask.ps1

' Create objects
Dim shell, fso
Set shell = CreateObject("WScript.Shell")
Set fso = CreateObject("Scripting.FileSystemObject")

' PowerShell script path (using $(if ($useOneDriveEnv) { "environment variable" } else { "absolute path" }))
Dim psScriptPath
$(if ($useOneDriveEnv) {
"psScriptPath = shell.ExpandEnvironmentStrings(`"$oneDriveEnvPath`")"
} else {
"psScriptPath = `"$ScriptPath`""
})

' Verify PowerShell script exists
If Not fso.FileExists(psScriptPath) Then
    MsgBox "PowerShell script not found at: " & psScriptPath & vbCrLf & vbCrLf & _
           "Please ensure the Satisfactory Blueprint Sync is properly installed.", _
           vbCritical, "Satisfactory Blueprint Sync - Script Not Found"
    WScript.Quit 1
End If

' Find Windows PowerShell executable
Dim pwshPath, pwshFound
pwshPath = ""
pwshFound = False

' Try Windows PowerShell locations first
Dim ps5Paths(1)
ps5Paths(0) = shell.ExpandEnvironmentStrings("%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe")
ps5Paths(1) = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe"

For i = 0 To UBound(ps5Paths)
    If fso.FileExists(ps5Paths(i)) Then
        pwshPath = ps5Paths(i)
        pwshFound = True
        Exit For
    End If
Next

' Final fallback - try PATH
If Not pwshFound Then
    On Error Resume Next
    Dim testResult
    testResult = shell.Run("powershell.exe -Command ""exit 0""", 0, True)
    If Err.Number = 0 And testResult = 0 Then
        pwshPath = "powershell.exe"
        pwshFound = True
    End If
    On Error GoTo 0
End If

' If no PowerShell found, show error and exit
If Not pwshFound Then
    MsgBox "Windows PowerShell is not installed on this system." & vbCrLf & vbCrLf & _
           "Windows PowerShell 5.1 should be available by default on Windows 10/11.", _
           vbCritical, "Satisfactory Blueprint Sync - PowerShell Not Found"
    WScript.Quit 1
End If

' Build the PowerShell command with full paths and optimal parameters
Dim psCommand
psCommand = """" & pwshPath & """ -NoProfile -WindowStyle Hidden -ExecutionPolicy Bypass -File """ & psScriptPath & """"

' Execute PowerShell with window hidden (parameter 0 = completely hidden)
' Parameter 0 ensures no console window appears at all
shell.Run psCommand, 0

' Clean up
Set shell = Nothing
Set fso = Nothing
"@

# Write the customized VBScript
Set-Content -Path $VBSPath -Value $vbsContent -Encoding ASCII
Write-Host "Customized VBScript wrapper created: $VBSPath" -ForegroundColor Green

# Set the OneDrive folder to be available offline (pinned)
Write-Host "Configuring OneDrive offline availability..." -ForegroundColor Yellow
$satisfactoryFolder = Split-Path $InstallPath -Parent
try {
    # Check if we're actually in a OneDrive folder
    if ($satisfactoryFolder -notlike "*\OneDrive*") {
        Write-Warning "Path doesn't appear to be in OneDrive: $satisfactoryFolder"
        Write-Host "Skipping offline availability configuration" -ForegroundColor Yellow
    }
    else {
        # Pin the Satisfactory folder and ALL contents recursively using lowercase +p
        # Note: OneDrive Files On-Demand uses lowercase attributes: +p for pinned, +u for unpinned
        Write-Host "Pinning OneDrive folder and ALL contents for offline availability: $satisfactoryFolder" -ForegroundColor Yellow

        # First pin all existing files and folders recursively
        $result = & attrib +p "$satisfactoryFolder\*" /S /D 2>&1
        if ($LASTEXITCODE -eq 0) {
            # Also pin the root folder itself to ensure new files inherit the pinned state
            & attrib +p "$satisfactoryFolder" 2>&1 | Out-Null
            Write-Host "Successfully pinned OneDrive folder recursively for complete offline availability: $satisfactoryFolder" -ForegroundColor Green
        }
        else {
            Write-Warning "Could not pin all OneDrive content. Trying alternative approach..."
            Write-Warning "Error: $result"

            # Fallback: Try pinning just the root folder with recursive flag
            $fallbackResult = & attrib +p "$satisfactoryFolder" /S /D 2>&1
            if ($LASTEXITCODE -eq 0) {
                Write-Host "Successfully pinned folder with fallback method: $satisfactoryFolder" -ForegroundColor Yellow
            }
            else {
                Write-Warning "Fallback also failed. You may need to manually set to 'Always keep on this device'"
                Write-Warning "Fallback error: $fallbackResult"
                Write-Host "Note: Right-click the folder and select 'Always keep on this device'" -ForegroundColor Cyan
            }
        }
    }
}
catch {
    Write-Warning "Error checking/setting OneDrive availability: $_"
}

Write-Host ""
Write-Host "Installing Satisfactory Blueprint Sync Scheduled Task" -ForegroundColor Green
Write-Host "==========================================" -ForegroundColor Green
Write-Host "Task Name: $TaskName"
Write-Host "Script Path: $ScriptPath"
Write-Host "Install Path: $InstallPath"
Write-Host "Interval: Every $IntervalMinutes minutes"
Write-Host "Windows PowerShell: $powershellPath"
Write-Host ""

# Check if task already exists
$existingTask = Get-ScheduledTask -TaskName $TaskName -ErrorAction SilentlyContinue

if ($existingTask) {
    if (!$Force) {
        $response = Read-Host "Task '$TaskName' already exists. Do you want to replace it? (Y/N)"
        if ($response -ne 'Y' -and $response -ne 'y') {
            Write-Host "Installation cancelled." -ForegroundColor Yellow
            exit 0
        }
    }

    Write-Host "Removing existing task..." -ForegroundColor Yellow
    Unregister-ScheduledTask -TaskName $TaskName -Confirm:$false
}

# Create the scheduled task
try {
    # Define the action (what the task will do)
    # Use VBScript wrapper instead of direct PowerShell for completely silent execution
    $action = New-ScheduledTaskAction `
        -Execute "wscript.exe" `
        -Argument "`"$VBSPath`"" `
        -WorkingDirectory (Split-Path $VBSPath -Parent)

    # Define the triggers (when the task will run)
    # 1. Daily trigger (without repetition initially)
    $dailyTrigger = New-ScheduledTaskTrigger -Daily -At "00:00:00"

    # 2. Logon trigger - runs when user logs in
    $logonTrigger = New-ScheduledTaskTrigger -AtLogOn -User $env:USERNAME

    # Create triggers array
    $triggers = @($dailyTrigger, $logonTrigger)

    # Define the principal (who runs the task and how)
    # Using Interactive logon for reliable execution with VBScript wrapper for silent operation
    $principal = New-ScheduledTaskPrincipal `
        -UserId $env:USERNAME `
        -LogonType Interactive `
        -RunLevel Highest

    # Define settings (matching your XML configuration)
    $settings = New-ScheduledTaskSettingsSet `
        -AllowStartIfOnBatteries `
        -DontStopIfGoingOnBatteries `
        -StartWhenAvailable `
        -DontStopOnIdleEnd `
        -ExecutionTimeLimit (New-TimeSpan -Hours 1) `
        -MultipleInstances IgnoreNew `
        -RestartCount 3 `
        -RestartInterval (New-TimeSpan -Minutes 1)

    # Create the task
    $task = New-ScheduledTask `
        -Action $action `
        -Trigger $triggers `
        -Principal $principal `
        -Settings $settings `
        -Description "Synchronizes Satisfactory blueprints to OneDrive every $IntervalMinutes minutes (using VBScript wrapper for silent execution)"

    # Register the task
    Register-ScheduledTask `
        -TaskName $TaskName `
        -InputObject $task `
        -Force | Out-Null

    Write-Host "Task registered. Configuring repetition..." -ForegroundColor Yellow

    # Now modify the triggers to add repetition (this is the key step!)
    $registeredTask = Get-ScheduledTask -TaskName $TaskName

    # Configure repetition for the daily trigger (first trigger, index 0)
    $registeredTask.Triggers[0].Repetition.Duration = "P1D"     # Repeat for 1 day
    $registeredTask.Triggers[0].Repetition.Interval = "PT$($IntervalMinutes)M"  # Every X minutes
    $registeredTask.Triggers[0].Repetition.StopAtDurationEnd = $false

    # Update the task with the modified triggers
    Set-ScheduledTask -InputObject $registeredTask | Out-Null

    Write-Host "`nScheduled task installed successfully!" -ForegroundColor Green

    # Display task information
    Write-Host "`nTask Details:" -ForegroundColor Cyan
    $registeredTask = Get-ScheduledTask -TaskName $TaskName
    Write-Host "  State: $($registeredTask.State)"
    Write-Host "  Path: $($registeredTask.TaskPath)"
    Write-Host "  Next Run Time: $(($registeredTask | Get-ScheduledTaskInfo).NextRunTime)"

    # Test run option
    Write-Host "`nWould you like to test the task now? (Y/N): " -NoNewline
    $testResponse = Read-Host
    if ($testResponse -eq 'Y' -or $testResponse -eq 'y') {
        Write-Host "Starting test run..." -ForegroundColor Yellow
        Start-ScheduledTask -TaskName $TaskName

        Start-Sleep -Seconds 3

        $taskInfo = Get-ScheduledTask -TaskName $TaskName | Get-ScheduledTaskInfo
        Write-Host "Last Run Time: $($taskInfo.LastRunTime)"
        Write-Host "Last Task Result: 0x$($taskInfo.LastTaskResult.ToString('X8'))"

        if ($taskInfo.LastTaskResult -eq 0) {
            Write-Host "Test run completed successfully!" -ForegroundColor Green
        }
        else {
            Write-Host "Test run may have encountered issues. Check the logs." -ForegroundColor Yellow
        }
    }

    Write-Host "`nInstallation complete!" -ForegroundColor Green
    Write-Host "PowerShell script installed to: $ScriptPath"
    Write-Host "VBScript wrapper installed to: $VBSPath"
    Write-Host "The sync task will run every $IntervalMinutes minutes silently in the background."
    Write-Host "Task uses Interactive logon with VBScript wrapper for completely hidden execution."
    Write-Host "Logs will be saved to: `$env:OneDrive\Documents\Satisfactory\logs"

    # Provide management commands
    Write-Host "`nUseful commands:" -ForegroundColor Cyan
    Write-Host "  View task status:    Get-ScheduledTask -TaskName '$TaskName' | Get-ScheduledTaskInfo"
    Write-Host "  Run task manually:   Start-ScheduledTask -TaskName '$TaskName'"
    Write-Host "  Disable task:        Disable-ScheduledTask -TaskName '$TaskName'"
    Write-Host "  Enable task:         Enable-ScheduledTask -TaskName '$TaskName'"
    Write-Host "  Remove task:         Unregister-ScheduledTask -TaskName '$TaskName' -Confirm:`$false"
    Write-Host "  Run script directly: wscript.exe `"$VBSPath`" (or powershell.exe -ExecutionPolicy Bypass -File `"$ScriptPath`")"
}
catch {
    Write-Error "Failed to create scheduled task: $_"
    exit 1
}